System.register(['@tanstack/query-core', 'jotai'], (function (exports) {
  'use strict';
  var QueryClient, QueryObserver, InfiniteQueryObserver, isCancelledError, atom;
  return {
    setters: [function (module) {
      QueryClient = module.QueryClient;
      QueryObserver = module.QueryObserver;
      InfiniteQueryObserver = module.InfiniteQueryObserver;
      isCancelledError = module.isCancelledError;
    }, function (module) {
      atom = module.atom;
    }],
    execute: (function () {

      exports({
        atomWithInfiniteQuery: atomWithInfiniteQuery,
        atomWithQuery: atomWithQuery
      });

      const queryClientAtom = exports('queryClientAtom', atom(new QueryClient()));

      function atomWithQuery(createQuery, getQueryClient = (get) => get(queryClientAtom)) {
        const previousDataCache = /* @__PURE__ */ new WeakMap();
        const queryDataAtom = atom((get) => {
          const queryClient = getQueryClient(get);
          const options = typeof createQuery === "function" ? createQuery(get) : createQuery;
          const observer = new QueryObserver(queryClient, options);
          const initialResult = observer.getCurrentResult();
          if (initialResult.data === void 0 && options.keepPreviousData && previousDataCache.has(queryClient)) {
            initialResult.data = previousDataCache.get(queryClient);
          }
          let resolve = null;
          const makePending = () => new Promise((r) => {
            resolve = r;
          });
          const resultAtom = atom(
            initialResult.data === void 0 && options.enabled !== false ? makePending() : initialResult
          );
          let setResult = null;
          const listener = (result) => {
            if (result.isFetching || !result.isError && result.data === void 0) {
              return;
            }
            if (!resolve && !setResult) {
              throw new Error("setting result without mount");
            }
            if (resolve) {
              resolve(result);
              resolve = null;
            }
            if (setResult) {
              setResult(result);
            }
            if (result.data !== void 0) {
              previousDataCache.set(queryClient, result.data);
            }
          };
          let unsubscribe = null;
          let timer;
          const startQuery = () => {
            if (!setResult && unsubscribe) {
              clearTimeout(timer);
              unsubscribe();
              unsubscribe = null;
            }
            if (options.enabled !== false) {
              if (setResult) {
                observer.refetch({ cancelRefetch: true }).then(setResult);
              } else {
                unsubscribe = observer.subscribe(listener);
              }
            }
            if (!setResult) {
              timer = setTimeout(() => {
                if (unsubscribe) {
                  unsubscribe();
                  unsubscribe = null;
                }
              }, 1e3);
            }
          };
          startQuery();
          resultAtom.onMount = (update) => {
            setResult = update;
            if (unsubscribe) {
              clearTimeout(timer);
            } else {
              startQuery();
            }
            return () => {
              setResult = null;
              if (unsubscribe) {
                unsubscribe();
              }
            };
          };
          return { resultAtom, makePending, startQuery };
        });
        const queryAtom = atom(
          (get) => {
            const { resultAtom } = get(queryDataAtom);
            const result = get(resultAtom);
            if (result.isError) {
              throw result.error;
            }
            return result.data;
          },
          (get, set, action) => {
            const { resultAtom, makePending, startQuery } = get(queryDataAtom);
            switch (action.type) {
              case "refetch": {
                set(resultAtom, makePending());
                startQuery();
              }
            }
          }
        );
        return queryAtom;
      }

      function atomWithInfiniteQuery(createQuery, getQueryClient = (get) => get(queryClientAtom)) {
        const queryDataAtom = atom(
          (get) => {
            const queryClient = getQueryClient(get);
            const options = typeof createQuery === "function" ? createQuery(get) : createQuery;
            const defaultedOptions = queryClient.defaultQueryOptions(options);
            const observer = new InfiniteQueryObserver(queryClient, defaultedOptions);
            const initialResult = observer.getCurrentResult();
            let resolve = null;
            const resultAtom = atom(
              initialResult.data === void 0 && options.enabled !== false ? new Promise((r) => {
                resolve = r;
              }) : initialResult
            );
            let setResult = () => {
              throw new Error("setting result without mount");
            };
            const state = {
              isMounted: false,
              unsubscribe: null
            };
            const listener = (result) => {
              if (result.isFetching || !result.isError && result.data === void 0 || result.isError && isCancelledError(result.error)) {
                return;
              }
              if (resolve) {
                setTimeout(() => {
                  var _a;
                  if (!state.isMounted) {
                    (_a = state.unsubscribe) == null ? void 0 : _a.call(state);
                    state.unsubscribe = null;
                  }
                }, 1e3);
                resolve(result);
                resolve = null;
              } else {
                setResult(result);
              }
            };
            if (options.enabled !== false) {
              state.unsubscribe = observer.subscribe(listener);
            }
            resultAtom.onMount = (update) => {
              setResult = update;
              state.isMounted = true;
              if (options.enabled !== false && !state.unsubscribe) {
                state.unsubscribe = observer.subscribe(listener);
                listener(observer.getCurrentResult());
              }
              return () => {
                var _a;
                return (_a = state.unsubscribe) == null ? void 0 : _a.call(state);
              };
            };
            return { options, resultAtom, observer, state };
          },
          (get, set, action) => {
            var _a;
            const { options, resultAtom, observer, state } = get(queryDataAtom);
            if (options.enabled === false) {
              return;
            }
            switch (action.type) {
              case "refetch": {
                set(resultAtom, new Promise(() => {
                }));
                if (!state.isMounted) {
                  (_a = state.unsubscribe) == null ? void 0 : _a.call(state);
                  state.unsubscribe = null;
                }
                observer.refetch(action.payload).then((result) => {
                  set(resultAtom, result);
                });
                return;
              }
              case "fetchPreviousPage": {
                observer.fetchPreviousPage();
                return;
              }
              case "fetchNextPage": {
                observer.fetchNextPage();
                return;
              }
            }
          }
        );
        const queryAtom = atom(
          (get) => {
            const { resultAtom } = get(queryDataAtom);
            const result = get(resultAtom);
            if (result.isError) {
              throw result.error;
            }
            return result.data;
          },
          (_get, set, action) => set(queryDataAtom, action)
        );
        return queryAtom;
      }

    })
  };
}));
